# frozen_string_literal: true

require 'json'
require 'typhoeus'
require 'fileutils'

module Wpxf
  # A self updater that uses the latest release from GitHub as the target.
  class GitHubUpdater
    def latest_release_url
      'https://api.github.com/repos/rastating/wordpress-exploit-framework/releases/latest'
    end

    # Get information about the latest update available on GitHub.
    # @param current_version [String] the current version number in use.
    # @return [Hash, nil] a hash containing the :release_notes, :zip_url and :release_name, or nil if there is no update.
    def get_update(current_version)
      res = Typhoeus.get(latest_release_url)
      return nil unless res&.code == 200

      begin
        update = JSON.parse(res.body)
      rescue JSON::ParserError
        return nil
      end

      begin
        return nil if Gem::Version.new(current_version) >= Gem::Version.new(update['tag_name'].sub(/^v/, ''))
      rescue
        return nil
      end

      { release_notes: update['body'], zip_url: update['zipball_url'], release_name: update['name'] }
    end

    # Download and apply an update from the specified URL.
    # @param zip_url [String] the URL to fetch the update from.
    def download_and_apply_update(zip_url)
      tmp = create_tmp_directory
      zip_filename = File.join(tmp, 'update.zip')

      download_update_zip(zip_url, zip_filename)

      Zip::File.open(zip_filename) do |zip_file|
        zip_file.each do |entry|
          entry.extract File.join(tmp, entry.name)
        end
      end

      Dir.glob(File.join(tmp, 'rastating-wordpress-exploit-framework*/*'), File::FNM_DOTMATCH) do |f|
        next if f =~ /\.$/
        FileUtils.cp_r(f, Wpxf.app_path)
      end

      FileUtils.rm_rf(tmp)
    end

    private

    def create_tmp_directory
      tmp = File.join(Dir.tmpdir, "wpxf_update_#{object_id}")
      FileUtils.mkdir_p(tmp)
      tmp
    end

    def download_update_zip(zip_url, local_filename)
      zip = File.open(local_filename, 'wb')
      request = Typhoeus::Request.new(zip_url, followlocation: true)
      request.on_headers do |response|
        raise 'Request failed' if response.code != 200
      end

      request.on_body do |chunk|
        zip.write(chunk)
      end

      request.on_complete do
        zip.close
      end

      request.run
    end
  end
end
